<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–¢–¢–ö –ë–∞—Ä–∞</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #E0E0E0;
            color: #333333;
            min-height: 100vh;
            background-image: linear-gradient(135deg, #F9F9F9 0%, #E8E8E8 100%);
            background-attachment: fixed;
        }

        /* –û–±—â–∏–π —Å—Ç–∏–ª—å –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ */
        .metal-effect {
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.7);
            border-radius: 12px; 
            box-shadow: 
                0 4px 15px rgba(0, 0, 0, 0.1),
                0 0 10px rgba(255, 255, 255, 0.8) inset;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        /* –£–ª—É—á—à–µ–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ –¥–ª—è –æ–±—â–∏—Ö "metal-effect" */
        .metal-effect:hover {
            border-color: rgba(167, 215, 249, 1); /* –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–π –∞–∫—Ü–µ–Ω—Ç */
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.15),
                0 0 20px rgba(167, 215, 249, 0.8) inset; /* –ë–æ–ª–µ–µ —Å–∏–ª—å–Ω–æ–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ */
            transform: translateY(-2px) scale(1.01); /* –ù–µ–º–Ω–æ–≥–æ –ø–æ–¥–Ω–∏–º–∞–µ—Ç—Å—è –∏ —á—É—Ç—å —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è */
        }
        
        .metal-effect:active {
             transform: translateY(0) scale(0.98);
        }

        /* --- –°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–π —ç—Ñ—Ñ–µ–∫—Ç –¥–ª—è –∫–∞—Ä—Ç–æ—á–µ–∫ –≤ —Å–µ—Ç–∫–µ --- */
        .card-item:hover {
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.2), /* –ë–æ–ª–µ–µ –≤—ã—Ä–∞–∂–µ–Ω–Ω–∞—è —Ç–µ–Ω—å */
                0 0 30px rgba(167, 215, 249, 1); /* –°–≤–µ—á–µ–Ω–∏–µ —Å–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–≥–æ —Ü–≤–µ—Ç–∞ */
            border-color: rgba(167, 215, 249, 1);
            transform: translateY(-5px) scale(1.02); /* –ß—É—Ç—å –±–æ–ª—å—à–µ –ø–æ–¥–Ω–∏–º–∞–µ—Ç—Å—è –∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è */
        }

        .card-item:active {
            transform: translateY(0) scale(0.98); /* –≠—Ñ—Ñ–µ–∫—Ç "–Ω–∞–∂–∞—Ç–∏—è" - –≤–¥–∞–≤–ª–∏–≤–∞–Ω–∏–µ */
            box-shadow: 
                0 2px 5px rgba(0, 0, 0, 0.1),
                0 0 10px rgba(167, 215, 249, 0.5); /* –ë–æ–ª–µ–µ –º—è–≥–∫–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ */
            border-color: rgba(167, 215, 249, 0.5);
        }
        /* -------------------------------------------------------- */
        
        /* –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è –∫–∞—Ä—Ç–æ—á–µ–∫ –≤ —Å–µ—Ç–∫–µ */
        .card-enter {
            animation: fadeInSlideUp 0.6s ease-out forwards;
            opacity: 0;
        }
        
        @keyframes fadeInSlideUp {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.5); 
            backdrop-filter: blur(8px);
        }
        
        dialog[open] {
            max-height: 95vh;
            opacity: 0;
            animation: modalFadeIn 0.3s ease-out forwards;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.2); 
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #4A90E2;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .ingredient-button {
            color: #4A90E2;
            font-weight: 600;
            text-decoration: underline;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            text-align: left;
            display: inline;
        }
        .ingredient-button:hover {
            color: #0056b3;
        }

        #modalIngredientsList, #modalStepsList {
            list-style: none;
            padding-left: 0;
        }

        .close-button {
            background-color: rgba(255, 255, 255, 0.8);
            color: #333;
            transition: all 0.2s;
        }
        .close-button:hover {
            background-color: #4A90E2;
            color: white;
            transform: rotate(90deg);
        }
        
        /* –°—Ç–∏–ª—å –¥–ª—è –∫–Ω–æ–ø–∫–∏ –ù–∞–∑–∞–¥ */
        .back-button {
            background-color: rgba(255, 255, 255, 0.8);
            color: #555;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
        }
        .back-button:hover {
            background-color: #4A90E2;
            color: white;
            transform: translateX(-3px); /* –ê–Ω–∏–º–∞—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –≤–ª–µ–≤–æ */
        }
        
        /* –°–ø–µ—Ü —Å—Ç–∏–ª—å –¥–ª—è –∑–∞–º–µ—Ç–æ–∫ –≤ —Ä–µ—Ü–µ–ø—Ç–µ */
        .recipe-note {
            color: #666;
            font-style: italic;
            font-size: 0.95em;
            margin-top: -0.25rem;
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
        }

        /* –°—Ç–∏–ª—å –∫–Ω–æ–ø–æ–∫ –≤—ã–±–æ—Ä–∞ –≤–∞—Ä–∏–∞—Ü–∏–∏ */
        .variation-btn {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.2s;
            border: 1px solid #e5e7eb;
            background-color: #f3f4f6;
            color: #4b5563;
            white-space: nowrap;
        }
        .variation-btn:hover {
            background-color: #e5e7eb;
        }
        .variation-btn.active {
            background-color: #4A90E2;
            color: white;
            border-color: #4A90E2;
            box-shadow: 0 2px 5px rgba(74, 144, 226, 0.3);
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <header class="text-center mb-8">
        <h1 class="text-5xl font-bold text-gray-800 drop-shadow-lg" style="text-shadow: 0 0 10px #FFFFFF;">–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –ö–∞—Ä—Ç—ã –ë–∞—Ä–∞</h1>
        <p class="text-gray-500 mt-2">–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –∫–∞—Ç–∞–ª–æ–≥ —Å –ø–µ—Ä–µ—Ö–æ–¥–∞–º–∏ –º–µ–∂–¥—É —Å–æ—Å—Ç–∞–≤–Ω—ã–º–∏ —á–∞—Å—Ç—è–º–∏.</p>
    </header>

    <!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
    <div class="flex flex-col sm:flex-row justify-center items-center mb-4 gap-4 max-w-3xl mx-auto">
        <select id="categoryFilter" class="w-full sm:w-1/3 p-4 text-lg text-gray-800 metal-effect focus:outline-none focus:ring-2 focus:ring-blue-300">
            <option value="">–í—Å–µ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏</option>
        </select>
        
        <input type="text" id="searchBar" placeholder="üîç –ü–æ–∏—Å–∫..." 
               class="w-full sm:w-2/3 p-4 text-lg text-gray-800 metal-effect focus:outline-none focus:ring-2 focus:ring-blue-300 placeholder-gray-500">
    </div>
    <!-- –°—á–µ—Ç—á–∏–∫ -->
    <div class="text-center mb-8 text-sm text-gray-500">
        <span id="itemsCount">–ó–∞–≥—Ä—É–∑–∫–∞...</span>
    </div>

    <div id="statusIndicator" class="text-center p-8">
        <div id="loadingIndicator" class="flex flex-col items-center">
            <div class="spinner"></div>
            <p class="mt-4 text-gray-600">–ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...</p>
        </div>
    </div>
    
    <!-- –°–µ—Ç–∫–∞ -->
    <div id="cardGrid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-3 sm:gap-4 max-w-6xl mx-auto">
    </div>
    
    <dialog id="recipeModal" class="p-0 rounded-2xl metal-effect w-11/12 max-w-2xl lg:max-w-3xl mx-auto overflow-hidden">
        <div class="p-6 sm:p-8 bg-white/50 max-h-[95vh] overflow-y-auto">
            
            <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –Ω–∞–≤–∏–≥–∞—Ü–∏—è -->
            <div class="flex justify-between items-start mb-2 gap-4">
                <div class="flex items-center gap-3 flex-grow">
                    <button id="modalBackButton" onclick="goBack()" 
                            class="hidden back-button metal-effect rounded-full w-10 h-10 flex-shrink-0 font-bold"
                            title="–ù–∞–∑–∞–¥">
                        &#8592;
                    </button>
                    <h2 id="modalName" class="text-3xl font-extrabold text-gray-700 drop-shadow-md leading-tight" style="text-shadow: 0 0 5px #FFFFFF;"></h2>
                </div>
                
                <button onclick="document.getElementById('recipeModal').close()" 
                        class="close-button text-2xl font-bold p-2 metal-effect rounded-full w-10 h-10 flex items-center justify-center flex-shrink-0">
                    &times;
                </button>
            </div>
            
            <!-- –ö–û–ù–¢–ï–ô–ù–ï–† –î–õ–Ø –í–ê–†–ò–ê–¶–ò–ô -->
            <div id="variationContainer" class="flex flex-wrap gap-2 mb-6 hidden"></div>

            <div class="flex flex-col lg:flex-row gap-6">
                
                <div class="lg:w-1/3 flex flex-col items-center p-4 metal-effect flex-shrink-0">
                    <p id="modalVolume" class="text-lg text-gray-700 font-semibold mb-3"></p> 
                    <img id="modalImage" src="" alt="–§–æ—Ç–æ –Ω–∞–ø–∏—Ç–∫–∞" 
                        class="rounded-lg object-contain w-full h-auto max-h-[70vh] border-2 border-gray-300/50" 
                        onerror="this.onerror=null; this.src='https://placehold.co/300x400/FFFFFF/666666?text=–ù–µ—Ç+–§–æ—Ç–æ';" />
                </div>
                
                <div class="lg:w-2/3 space-y-6">
                    <div class="p-4 metal-effect">
                        <h3 class="text-xl font-semibold text-gray-700 mb-3 border-b pb-2 border-gray-300/50">–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã:</h3>
                        <ul id="modalIngredientsList" class="space-y-2 text-gray-700"></ul>
                    </div>
                    
                    <div class="p-4 metal-effect">
                        <h3 class="text-xl font-semibold text-gray-700 mb-3 border-b pb-2 border-gray-300/50">–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—è –ü—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è:</h3>
                        <ul id="modalStepsList" class="space-y-3 text-gray-700"></ul>
                    </div>
                </div>
            </div>
        </div>
    </dialog>

    <script>
        const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT0ukbh5K5GdykFFCDj-H0xUODUAneKWmbeJFfe4tLTCMEWKJgCkefhrCOtsKDB_QRRYySAvI1xOTh3/pub?gid=1617440067&single=true&output=csv";
        
        let allCardData = [];
        let groupedCardData = []; // –°–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        const cardDataMap = new Map();
        
        // --- –ü–ï–†–ï–ú–ï–ù–ù–´–ï –î–õ–Ø –ò–°–¢–û–†–ò–ò –ù–ê–í–ò–ì–ê–¶–ò–ò ---
        let modalHistory = []; 
        let currentModalGroup = null; // –¢–µ–ø–µ—Ä—å —Ö—Ä–∞–Ω–∏–º –≥—Ä—É–ø–ø—É (–º–∞—Å—Å–∏–≤ –∫–∞—Ä—Ç–æ—á–µ–∫)
        
        const cardGrid = document.getElementById('cardGrid');
        const searchBar = document.getElementById('searchBar');
        const statusIndicator = document.getElementById('statusIndicator');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const recipeModal = document.getElementById('recipeModal');
        const categoryFilter = document.getElementById('categoryFilter');
        const modalBackButton = document.getElementById('modalBackButton');
        const itemsCountLabel = document.getElementById('itemsCount');
        const variationContainer = document.getElementById('variationContainer');

        const sampleData = [
            {
                '–Ω–∞–∑–≤–∞–Ω–∏–µ': '–¢–∞–π–≥–µ—Ä –®—É–≥–∞—Ä –¢—ë–ø–ª—ã–π',
                '–æ–±—ä—ë–º': '400',
                '–∫–∞—Ç–µ–≥–æ—Ä–∏—è': '–ë–∞–±–ª –¢–∏',
                '—Å–æ—Å—Ç–∞–≤': '–ú–æ–ª–æ–∫–æ, —Å–∞—Ö–∞—Ä', 
                '—Ä–µ—Ü–µ–ø—Ç': '–ù–∞–≥—Ä–µ—Ç—å.', 
                '—Ñ–æ—Ç–æ': 'https://placehold.co/400x600/FFFFFF/666666?text=–¢–∞–π–≥–µ—Ä+–¢–µ–ø–ª—ã–π' 
            },
            {
                '–Ω–∞–∑–≤–∞–Ω–∏–µ': '–¢–∞–π–≥–µ—Ä –®—É–≥–∞—Ä –•–æ–ª–æ–¥–Ω—ã–π',
                '–æ–±—ä—ë–º': '400',
                '–∫–∞—Ç–µ–≥–æ—Ä–∏—è': '–ë–∞–±–ª –¢–∏',
                '—Å–æ—Å—Ç–∞–≤': '–ú–æ–ª–æ–∫–æ, —Å–∞—Ö–∞—Ä, –ª–µ–¥',
                '—Ä–µ—Ü–µ–ø—Ç': '–í–∑–±–∏—Ç—å.',
                '—Ñ–æ—Ç–æ': 'https://placehold.co/400x600/E0E0E0/666666?text=–¢–∞–π–≥–µ—Ä+–•–æ–ª–æ–¥–Ω—ã–π' 
            },
            {
                '–Ω–∞–∑–≤–∞–Ω–∏–µ': '–ê–π—Å –õ–∞—Ç—Ç–µ',
                '–æ–±—ä—ë–º': '300',
                '–∫–∞—Ç–µ–≥–æ—Ä–∏—è': '–ö–æ—Ñ–µ',
                '—Å–æ—Å—Ç–∞–≤': '–≠—Å–ø—Ä–µ—Å—Å–æ, –º–æ–ª–æ–∫–æ, –ª–µ–¥',
                '—Ä–µ—Ü–µ–ø—Ç': '–í–∑–±–∏—Ç—å',
                '—Ñ–æ—Ç–æ': 'https://placehold.co/400x600/E0E0E0/666666?text=–ê–π—Å+–õ–∞—Ç—Ç–µ' 
            },
            {
                '–Ω–∞–∑–≤–∞–Ω–∏–µ': '–ê–π—Å –õ–∞—Ç—Ç–µ –ë–∞–Ω–∞–Ω',
                '–æ–±—ä—ë–º': '300',
                '–∫–∞—Ç–µ–≥–æ—Ä–∏—è': '–ö–æ—Ñ–µ',
                '—Å–æ—Å—Ç–∞–≤': '–≠—Å–ø—Ä–µ—Å—Å–æ, –º–æ–ª–æ–∫–æ, —Å–∏—Ä–æ–ø –±–∞–Ω–∞–Ω',
                '—Ä–µ—Ü–µ–ø—Ç': '–í–∑–±–∏—Ç—å',
                '—Ñ–æ—Ç–æ': 'https://placehold.co/400x600/E0E0E0/666666?text=–ê–π—Å+–õ–∞—Ç—Ç–µ+–ë–∞–Ω–∞–Ω' 
            }
        ];

        // --- CSV –ü–ê–†–°–ï–† ---
        function parseCSVRobust(text, delimiter = ',') {
            const rows = [];
            let currentRow = [];
            let currentField = '';
            let inQuotes = false;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        currentField += '"';
                        i++; 
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === delimiter && !inQuotes) {
                    currentRow.push(currentField);
                    currentField = '';
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (char === '\r' && nextChar === '\n') i++; 
                    currentRow.push(currentField);
                    rows.push(currentRow);
                    currentRow = [];
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            if (currentField || currentRow.length > 0) {
                currentRow.push(currentField);
                rows.push(currentRow);
            }
            return rows;
        }

        // --- –£–º–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –¥–ª—è —Å–æ—Å—Ç–∞–≤–∞ ---
        function parseSmartIngredients(rawIngredients, currentVolume) {
            let unit = '–º–ª'; 
            let volume = currentVolume;
            
            if (rawIngredients) {
                const volumeMatch = rawIngredients.match(/((?:–û–±—ä–µ–º|–û–±—ä—ë–º|–í–µ—Å).*?)(\d+(?:[.,]\d+)?)/i);
                if (volumeMatch) {
                    const context = volumeMatch[1].toLowerCase();
                    const val = volumeMatch[2];
                    if (context.includes('–≥—Ä') || context.includes('–≥.') || context.includes(' g') || context.includes(' gr')) {
                        unit = '–≥—Ä';
                    } else if (context.includes('–º–ª') || context.includes('ml')) {
                        unit = '–º–ª';
                    } else if (context.includes('–≤–µ—Å')) {
                        unit = '–≥—Ä'; 
                    } else {
                        unit = '–º–ª'; 
                    }
                    volume = val;
                }
            }

            if (!rawIngredients) return { cleanIngredients: '', extractedVolume: currentVolume, extractedUnit: '–º–ª' };

            let cleanText = rawIngredients.replace(/(?:–û–±—ä–µ–º|–û–±—ä—ë–º|–í–µ—Å).*?(\d+(?:[.,]\d+)?).*$/gmi, '');
            let lines = cleanText.split(/[\n;]+/);
            
            let processedLines = lines.map(line => {
                let l = line.trim();
                if (!l) return null;
                l = l.replace(/^(\d+)([–∞-—è–ê-–Øa-zA-Z])/u, '$1. $2');
                l = l.replace(/([–∞-—è–ê-–Øa-zA-Z])\s*(–≥—Ä|–≥|–º–ª|–ª|gr|g|ml|l)\.?\s*(\d+(?:[.,]\d+)?)/giu, '$1 - $3$2');
                return l;
            }).filter(l => l); 

            return {
                cleanIngredients: processedLines.join('; '), 
                extractedVolume: volume,
                extractedUnit: unit
            };
        }

        function parseSmartRecipe(rawRecipe) {
            if (!rawRecipe) return '';
            let lines = rawRecipe.split(/[\n;]+/);
            let processedLines = lines.map(line => {
                let l = line.trim();
                if (!l) return null;
                l = l.replace(/^(\d+)\.([^\s])/u, '$1. $2');
                l = l.replace(/^(\d)([–∞-—è–ê-–Øa-zA-Z])/u, '$1. $2');
                return l;
            }).filter(l => l);
            return processedLines.join('\n');
        }

        // --- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê –ì–†–£–ü–ü–ò–†–û–í–ö–ò (–û—á–∏—Å—Ç–∫–∞ –∏–º–µ–Ω–∏) ---
        function getCleanName(name, category) {
            if (!name) return "";
            
            const nameLower = name.toLowerCase();
            const categoryLower = category ? category.toLowerCase() : "";
            
            // 3. –ò–°–ö–õ–Æ–ß–ï–ù–ò–ï –ö–ê–¢–ï–ì–û–†–ò–ò –ö–û–§–ï
            // –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è –ö–æ—Ñ–µ –∏–ª–∏ Coffee, –º—ã –ù–ï –ß–ò–°–¢–ò–ú –∏–º—è –æ—Ç –¥–æ–±–∞–≤–æ–∫.
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª (–≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –¥—É–±–ª–µ–π, –Ω–æ –Ω–µ –≤–∞—Ä–∏–∞—Ü–∏–π)
            if (categoryLower.includes('–∫–æ—Ñ–µ') || categoryLower.includes('coffee')) {
                return name.trim();
            }

            // –°–ø–∏—Å–æ–∫ —Å–ª–æ–≤-–ø–∞—Ä–∞–∑–∏—Ç–æ–≤ –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏. 
            // –≠—Ç–æ —Å–ª–æ–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ "–Ω–µ –º–µ–Ω—è—é—Ç —Å—É—Ç—å" –Ω–∞–ø–∏—Ç–∫–∞, –∞ —Ç–æ–ª—å–∫–æ –µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ.
            // "–ë–∞–Ω–∞–Ω" –∏–ª–∏ "–ö–ª—É–±–Ω–∏–∫–∞" –°–Æ–î–ê –ù–ï –í–•–û–î–Ø–¢ (–ø–æ—ç—Ç–æ–º—É –ê–π—Å –õ–∞—Ç—Ç–µ –ë–∞–Ω–∞–Ω –æ—Å—Ç–∞–Ω–µ—Ç—Å—è —Å–æ–±–æ–π)
            const suffixesToRemove = [
                '—Ç–µ–ø–ª—ã–π', '—Ç—ë–ø–ª—ã–π', '—Ö–æ–ª–æ–¥–Ω—ã–π', '–≥–æ—Ä—è—á–∏–π', 
                'warm', 'hot', 'cold', 'ice', 'cool',
                '–±–µ–∑ –ø—Ñ', '—Å –ø—Ñ', '–±/–ø—Ñ', 'no pf',
                '–±–æ–ª—å—à–æ–π', '—Å—Ä–µ–¥–Ω–∏–π', '–º–∞–ª–µ–Ω—å–∫–∏–π',
                '–∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π', '–∫–ª–∞—Å—Å–∏–∫–∞', '–æ—Ä–∏–≥–∏–Ω–∞–ª'
            ];
            
            // –¢–∞–∫–∂–µ —É–¥–∞–ª—è–µ–º –æ–±—ä–µ–º—ã (300–º–ª, 0.4 –∏ —Ç.–¥.)
            // –ò —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–∫–æ–±–æ–∫ (...)
            
            let clean = nameLower;

            // 1. –£–¥–∞–ª—è–µ–º —Å–∫–æ–±–∫–∏ –∏ –≤—Å–µ –≤–Ω—É—Ç—Ä–∏
            clean = clean.replace(/\(.*\)/g, '');
            clean = clean.replace(/\[.*\]/g, '');

            // 2. –£–¥–∞–ª—è–µ–º –æ–±—ä–µ–º—ã –≤ –∫–æ–Ω—Ü–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä " 300–º–ª", " 0,5")
            clean = clean.replace(/\s+\d+([.,]\d+)?\s*(–º–ª|ml|–≥—Ä|gr|–≥|–ª)?\s*$/i, '');

            // 3. –£–¥–∞–ª—è–µ–º —Å–ª–æ–≤–∞ –∏–∑ —Å–ø–∏—Å–∫–∞ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∏ –≤ –∫–æ–Ω—Ü–µ –∏–ª–∏ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞)
            suffixesToRemove.forEach(word => {
                // –†–µ–≥—É–ª—è—Ä–∫–∞ –∏—â–µ—Ç —Å–ª–æ–≤–æ, –ø–µ—Ä–µ–¥ –∫–æ—Ç–æ—Ä—ã–º –ø—Ä–æ–±–µ–ª (–∏–ª–∏ –Ω–∞—á–∞–ª–æ —Å—Ç—Ä–æ–∫–∏)
                const regex = new RegExp(`(^|\\s)${word}(\\s|$)`, 'gi');
                clean = clean.replace(regex, ' ');
            });

            // –ß–∏—Å—Ç–∏–º —Ö–≤–æ—Å—Ç—ã –∏ –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
            clean = clean.replace(/\s+/g, ' ').trim();
            
            // –£–±–∏—Ä–∞–µ–º –∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è –≤ –∫–æ–Ω—Ü–µ
            clean = clean.replace(/[-:]$/, '').trim();

            // –ï—Å–ª–∏ —É–¥–∞–ª–∏–ª–∏ –≤–æ–æ–±—â–µ –≤—Å—ë, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª
            if (clean.length < 2) return name.trim();
            
            return clean; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã? –ù–µ—Ç, –ª—É—á—à–µ –∫–∞–∫ –µ—Å—Ç—å
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–º–µ–Ω–∏ –≥—Ä—É–ø–ø—ã (–¥–µ–ª–∞–µ—Ç –ø–µ—Ä–≤—ã–µ –±—É–∫–≤—ã –∑–∞–≥–ª–∞–≤–Ω—ã–º–∏)
        function capitalizeWords(str) {
            return str.replace(/\b\w/g, l => l.toUpperCase());
        }

        function groupCards(data) {
            const groupsMap = new Map();
            
            data.forEach(card => {
                const name = card['–Ω–∞–∑–≤–∞–Ω–∏–µ'];
                const category = card['–∫–∞—Ç–µ–≥–æ—Ä–∏—è'];
                
                // –ü–æ–ª—É—á–∞–µ–º "—á–∏—Å—Ç–æ–µ –∏–º—è" (–∫–ª—é—á –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏)
                // –î–ª—è –ö–æ—Ñ–µ –æ–Ω–æ –≤–µ—Ä–Ω–µ—Ç –ø–æ–ª–Ω–æ–µ –∏–º—è ("–∞–π—Å –ª–∞—Ç—Ç–µ –±–∞–Ω–∞–Ω"), –¥–ª—è –ë–∞–±–ª –¢–∏ - —á–∏—Å—Ç–æ–µ ("—Ç–∞–π–≥–µ—Ä —à—É–≥–∞—Ä")
                const cleanNameKey = getCleanName(name, category).toLowerCase();
                
                // –§–æ—Ä–º–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á: –ö–∞—Ç–µ–≥–æ—Ä–∏—è + –ß–∏—Å—Ç–æ–µ –∏–º—è
                const mapKey = `${category.toLowerCase()}|${cleanNameKey}`;
                
                if (!groupsMap.has(mapKey)) {
                    // –ü—ã—Ç–∞–µ–º—Å—è —Å–¥–µ–ª–∞—Ç—å –∫—Ä–∞—Å–∏–≤–æ–µ –∏–º—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã
                    // –ë–µ—Ä–µ–º cleanNameKey –∏ –¥–µ–ª–∞–µ–º –ø–µ—Ä–≤—ã–µ –±—É–∫–≤—ã –∑–∞–≥–ª–∞–≤–Ω—ã–º–∏, –∏–ª–∏ –±–µ—Ä–µ–º –∏–º—è –ø–µ—Ä–≤–æ–π –∫–∞—Ä—Ç—ã –µ—Å–ª–∏ –æ–Ω–æ —Å–æ–≤–ø–∞–¥–∞–µ—Ç
                    let displayGroupName = capitalizeWords(cleanNameKey);
                    
                    groupsMap.set(mapKey, {
                        commonName: displayGroupName, 
                        cards: []
                    });
                }
                
                groupsMap.get(mapKey).cards.push(card);
            });
            
            // –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º Map –æ–±—Ä–∞—Ç–Ω–æ –≤ –º–∞—Å—Å–∏–≤ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º
            return Array.from(groupsMap.values())
                .sort((a, b) => a.commonName.localeCompare(b.commonName));
        }
        
        function csvToObjectArray(csvText) {
            const firstLineEnd = csvText.indexOf('\n');
            const firstLine = csvText.substring(0, firstLineEnd > -1 ? firstLineEnd : csvText.length);
            
            let delimiter = ',';
            if ((firstLine.match(/;/g) || []).length > (firstLine.match(/,/g) || []).length) {
                delimiter = ';';
            } else if ((firstLine.match(/\|/g) || []).length > (firstLine.match(/,/g) || []).length) {
                delimiter = '|';
            }

            const rows = parseCSVRobust(csvText, delimiter);

            if (rows.length < 2) return [];
            
            const rawHeaders = rows[0];
            const headers = rawHeaders.map(h => h.toLowerCase().trim().replace(/^\ufeff/, ''));
            
            const requiredHeaders = ['–Ω–∞–∑–≤–∞–Ω–∏–µ', '—Å–æ—Å—Ç–∞–≤', '—Ä–µ—Ü–µ–ø—Ç', '–æ–±—ä—ë–º', '—Ñ–æ—Ç–æ'];
            const missingCriticalHeaders = requiredHeaders.filter(h => !headers.includes(h));
            
            if (missingCriticalHeaders.length > 0) {
                document.getElementById('statusIndicator').innerHTML = `–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –ù–µ—Ç –∫–æ–ª–æ–Ω–æ–∫ ${missingCriticalHeaders.join(', ')}`;
                return [];
            }
            
            const data = [];
            const categoryIndex = headers.indexOf('–∫–∞—Ç–µ–≥–æ—Ä–∏—è');

            for (let i = 1; i < rows.length; i++) {
                const values = rows[i];
                if (values.length === 0 || (values.length === 1 && values[0] === '')) continue;

                const obj = {};
                headers.forEach((header, index) => {
                    obj[header] = (index < values.length) ? values[index].trim() : "";
                });
                
                if (categoryIndex === -1) obj['–∫–∞—Ç–µ–≥–æ—Ä–∏—è'] = '–ë–µ–∑ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏';

                if (obj['–Ω–∞–∑–≤–∞–Ω–∏–µ'] && obj['–Ω–∞–∑–≤–∞–Ω–∏–µ'].trim() !== '') {
                    const smartIngredients = parseSmartIngredients(obj['—Å–æ—Å—Ç–∞–≤'], obj['–æ–±—ä—ë–º']);
                    obj['—Å–æ—Å—Ç–∞–≤'] = smartIngredients.cleanIngredients;
                    
                    if ((!obj['–æ–±—ä—ë–º'] || obj['–æ–±—ä—ë–º'].trim() === '' || obj['–æ–±—ä—ë–º'] === '-') && smartIngredients.extractedVolume) {
                        obj['–æ–±—ä—ë–º'] = smartIngredients.extractedVolume;
                    }
                    
                    obj['–µ–¥–∏–Ω–∏—Ü–∞'] = smartIngredients.extractedUnit;
                    obj['—Ä–µ—Ü–µ–ø—Ç'] = parseSmartRecipe(obj['—Ä–µ—Ü–µ–ø—Ç']);
                    data.push(obj);
                }
            }
            return data;
        }

        function renderGrid(groups) {
            cardGrid.innerHTML = '';
            if (groups.length > 0 && !statusIndicator.innerHTML.includes("–¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ")) {
                statusIndicator.innerHTML = ''; 
            }
            
            if (groups.length === 0) {
                statusIndicator.innerHTML = "<p class='text-gray-600 font-medium'>–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.</p>";
                itemsCountLabel.textContent = "–ù–∞–π–¥–µ–Ω–æ: 0";
                return;
            }
            
            itemsCountLabel.textContent = `–ü–æ–∫–∞–∑–∞–Ω–æ –ø–æ–∑–∏—Ü–∏–π: ${groups.length}`;

            groups.forEach((groupObj, index) => {
                const groupName = groupObj.commonName; 
                const cards = groupObj.cards;
                const mainCard = cards[0]; 
                
                const cardElement = document.createElement('div');
                cardElement.className = "metal-effect p-3 overflow-hidden cursor-pointer flex flex-col items-center text-center card-item"; 
                cardElement.classList.add('card-enter');
                cardElement.style.animationDelay = `${index * 0.05}s`; 

                let badge = '';
                if (cards.length > 1) {
                    badge = `<span class="absolute top-2 right-2 bg-blue-500 text-white text-[10px] font-bold px-2 py-0.5 rounded-full shadow-sm z-10">${cards.length} –≤–∞—Ä.</span>`;
                }

                cardElement.innerHTML = `
                    <div class="relative w-full h-24 mb-2">
                        ${badge}
                        <div class="w-full h-full rounded-lg border-2 border-gray-200 bg-white flex items-center justify-center overflow-hidden">
                            <img src="${mainCard['—Ñ–æ—Ç–æ'] || 'https://placehold.co/300x200/FFFFFF/666666?text=–ù–µ—Ç+–§–æ—Ç–æ'}" 
                                    alt="${groupName}" 
                                    class="w-full h-full object-contain" 
                                    onerror="this.onerror=null; this.src='https://placehold.co/300x200/CCCCCC/666666?text=–ù–µ—Ç+–§–æ—Ç–æ';" />
                        </div>
                    </div>
                    <h3 class="text-sm font-semibold text-gray-700 drop-shadow-sm w-full leading-tight mb-1">
                        ${groupName || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}
                    </h3>
                    <p class="text-xs text-gray-500 mt-1 mb-1">${mainCard['–∫–∞—Ç–µ–≥–æ—Ä–∏—è'] || '–ë–µ–∑ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏'}</p>
                    <p class="text-sm text-gray-600 drop-shadow-sm">${mainCard['–æ–±—ä—ë–º'] || '?'} ${mainCard['–µ–¥–∏–Ω–∏—Ü–∞'] || '–º–ª'}</p>
                `;
                
                cardElement.addEventListener('click', () => {
                    modalHistory = [];
                    openModal(groupObj);
                });
                cardGrid.appendChild(cardElement);
            });
        }
        
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ª–∏–Ω–∫–æ–≤–∫–∏
        function createLinkedIngredientElements(text) {
            let parts = [{ text: text, group: null }];
            
            const lookupMap = new Map();
            
            groupedCardData.forEach(groupObj => {
                if (groupObj.commonName && groupObj.commonName.length >= 3) {
                    lookupMap.set(groupObj.commonName.toLowerCase().trim(), groupObj);
                }
                groupObj.cards.forEach(card => {
                     if (card['–Ω–∞–∑–≤–∞–Ω–∏–µ'] && card['–Ω–∞–∑–≤–∞–Ω–∏–µ'].length >= 3) {
                        lookupMap.set(card['–Ω–∞–∑–≤–∞–Ω–∏–µ'].toLowerCase().trim(), groupObj);
                    }
                });
            });

            const sortedNames = Array.from(lookupMap.keys()).sort((a, b) => b.length - a.length);

            for (const dbName of sortedNames) {
                const newParts = [];
                for (const part of parts) {
                    if (part.group) {
                        newParts.push(part);
                        continue;
                    }
                    const regex = new RegExp(`(${escapeRegExp(dbName)})`, 'gi');
                    const splitArr = part.text.split(regex);
                    if (splitArr.length > 1) {
                        for (let i = 0; i < splitArr.length; i++) {
                            const chunk = splitArr[i];
                            if (!chunk) continue;
                            if (chunk.toLowerCase() === dbName) {
                                newParts.push({ text: chunk, group: lookupMap.get(dbName) });
                            } else {
                                newParts.push({ text: chunk, group: null });
                            }
                        }
                    } else {
                        newParts.push(part);
                    }
                }
                parts = newParts;
            }
            
            const fragment = document.createDocumentFragment();
            let foundAnyLink = false;

            parts.forEach(part => {
                if (part.group) {
                    foundAnyLink = true;
                    const btn = document.createElement('button');
                    btn.className = 'ingredient-button';
                    btn.textContent = part.text; 
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        if (currentModalGroup) modalHistory.push(currentModalGroup);
                        openModal(part.group);
                    };
                    fragment.appendChild(btn);
                } else {
                    fragment.appendChild(document.createTextNode(part.text));
                }
            });

            if (!foundAnyLink) {
                 const cleanName = text.toLowerCase().trim();
                 for (const dbName of sortedNames) {
                     if (dbName.includes(cleanName)) {
                         const group = lookupMap.get(dbName);
                         while(fragment.firstChild) fragment.removeChild(fragment.firstChild);
                         const btn = document.createElement('button');
                         btn.className = 'ingredient-button';
                         btn.textContent = text; 
                         btn.onclick = (e) => {
                            e.stopPropagation();
                            if (currentModalGroup) modalHistory.push(currentModalGroup);
                            openModal(group);
                         };
                         fragment.appendChild(btn);
                         return fragment;
                     }
                 }
            }
            return fragment;
        }

        function goBack() {
            if (modalHistory.length > 0) {
                const prevGroup = modalHistory.pop();
                openModal(prevGroup);
            }
        }

        function updateModalContent(card) {
            document.getElementById('modalName').textContent = card['–Ω–∞–∑–≤–∞–Ω–∏–µ'] || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è';
            
            const unit = card['–µ–¥–∏–Ω–∏—Ü–∞'] || '–º–ª';
            const label = unit === '–≥—Ä' ? '–í–µ—Å:' : '–û–±—ä–µ–º:';
            document.getElementById('modalVolume').textContent = `${label} ${card['–æ–±—ä—ë–º'] || '?'} ${unit}`; 
            
            const modalImage = document.getElementById('modalImage');
            modalImage.src = card['—Ñ–æ—Ç–æ'] || '';
            
            const ingredientsListEl = document.getElementById('modalIngredientsList');
            ingredientsListEl.innerHTML = '';
            
            const ingredients = card['—Å–æ—Å—Ç–∞–≤'] ? card['—Å–æ—Å—Ç–∞–≤'].split(/[;\r?\n]+/).filter(item => item.trim() !== '') : [];
            
            ingredients.forEach(item => {
                const cleanItem = item.trim(); 
                if (!cleanItem) return;

                const li = document.createElement('li');
                li.className = "text-gray-700";

                const match = cleanItem.match(/^([\d.,\s\w]+\s*)?([^:;-]+)([:;-].*)?$/); 

                let prefix = '';
                let ingredientName = cleanItem;
                let suffix = '';
                
                if (match) {
                    prefix = match[1] || '';
                    ingredientName = match[2] ? match[2].trim() : cleanItem; 
                    suffix = match[3] || '';
                } 
                if (prefix) li.appendChild(document.createTextNode(prefix));
                const contentFragment = createLinkedIngredientElements(ingredientName);
                li.appendChild(contentFragment);
                if (suffix) li.appendChild(document.createTextNode(suffix));
                
                ingredientsListEl.appendChild(li);
            });

            const stepsListEl = document.getElementById('modalStepsList');
            stepsListEl.innerHTML = '';
            const steps = card['—Ä–µ—Ü–µ–ø—Ç'] ? card['—Ä–µ—Ü–µ–ø—Ç'].split(/[;\r?\n]+/).filter(step => step.trim() !== '') : [];
            
            steps.forEach(step => {
                const cleanStep = step.trim(); 
                if (cleanStep) {
                    const li = document.createElement('li');
                    if (cleanStep.startsWith('(')) {
                        li.textContent = cleanStep;
                        li.className = "recipe-note"; 
                    } else if (!cleanStep.match(/^[\d.]+\s/)) {
                         li.innerHTML = `&bull; ${cleanStep}`;
                         li.className = "text-gray-700"; 
                    } else {
                        li.textContent = cleanStep;
                        li.className = "text-gray-700"; 
                    }
                    stepsListEl.appendChild(li);
                }
            });
        }

        function openModal(groupObj) {
            if (!groupObj || !groupObj.cards || groupObj.cards.length === 0) return;
            currentModalGroup = groupObj;

            if (modalHistory.length > 0) {
                modalBackButton.classList.remove('hidden');
            } else {
                modalBackButton.classList.add('hidden');
            }

            const cards = groupObj.cards;
            const commonName = groupObj.commonName;

            // –û—á–∏—Å—Ç–∫–∞ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ –∫–Ω–æ–ø–æ–∫ –≤–∞—Ä–∏–∞—Ü–∏–π
            variationContainer.innerHTML = '';
            
            if (cards.length > 1) {
                variationContainer.classList.remove('hidden');
                
                cards.forEach((card, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'variation-btn';
                    
                    // –ü—ã—Ç–∞–µ–º—Å—è —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –∫—Ä–∞—Ç–∫–æ–µ –∏–º—è –∫–Ω–æ–ø–∫–∏
                    let btnText = card['–Ω–∞–∑–≤–∞–Ω–∏–µ'];
                    
                    // –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã –≤ –æ–±—â–µ–º –∏–º–µ–Ω–∏ –¥–ª—è regex
                    const escapedCommon = commonName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regexCommon = new RegExp('^' + escapedCommon, 'i');
                    
                    if (regexCommon.test(btnText)) {
                        // –û—Ç—Ä–µ–∑–∞–µ–º –æ–±—â–µ–µ –∏–º—è –∏–∑ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏
                        btnText = btnText.replace(regexCommon, '').trim();
                        // –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–∫–æ–±–∫–∏ –∏–ª–∏ —Ç–∏—Ä–µ
                        btnText = btnText.replace(/^[\s\(\)-]+|[\s\)]+$/g, '');
                    }

                    if (btnText.length === 0) {
                        btnText = "–ö–ª–∞—Å—Å–∏–∫–∞"; 
                    } else {
                         // –î–µ–ª–∞–µ–º –ø–µ—Ä–≤—É—é –±—É–∫–≤—É –∑–∞–≥–ª–∞–≤–Ω–æ–π
                        btnText = btnText.charAt(0).toUpperCase() + btnText.slice(1);
                    }
                    
                    btn.textContent = btnText;
                    
                    btn.onclick = () => {
                        document.querySelectorAll('.variation-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        updateModalContent(card);
                    };
                    
                    variationContainer.appendChild(btn);
                });
                
                variationContainer.firstChild.classList.add('active');
            } else {
                variationContainer.classList.add('hidden');
            }

            updateModalContent(cards[0]);
            
            recipeModal.showModal();
        }

        function filterDrinks() {
            const textQuery = searchBar.value.toLowerCase().trim();
            const selectedCategory = categoryFilter.value; 

            const filteredGroups = groupedCardData.filter(groupObj => {
                return groupObj.cards.some(card => {
                    const name = card['–Ω–∞–∑–≤–∞–Ω–∏–µ'] ? card['–Ω–∞–∑–≤–∞–Ω–∏–µ'].toLowerCase() : '';
                    const cardCategory = card['–∫–∞—Ç–µ–≥–æ—Ä–∏—è'] ? card['–∫–∞—Ç–µ–≥–æ—Ä–∏—è'].trim() : '–ë–µ–∑ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏'; 

                    const matchesText = !textQuery || name.includes(textQuery);
                    const matchesCategory = !selectedCategory || cardCategory === selectedCategory;
                    return matchesText && matchesCategory;
                });
            });
            
            renderGrid(filteredGroups);
        }

        function populateCategoryFilter(data) {
            const categories = new Set();
            data.forEach(drink => {
                const category = drink['–∫–∞—Ç–µ–≥–æ—Ä–∏—è'] ? drink['–∫–∞—Ç–µ–≥–æ—Ä–∏—è'].trim() : '–ë–µ–∑ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏';
                if (category) categories.add(category);
            });
            categoryFilter.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '–í—Å–µ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏';
            categoryFilter.appendChild(defaultOption);
            const sortedCategories = Array.from(categories).sort();
            sortedCategories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
        }

        async function loadData() {
            cardGrid.innerHTML = '';
            statusIndicator.innerHTML = '';
            itemsCountLabel.textContent = "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ..."; 
            
            let fetchSuccess = false;

            if (CSV_URL) {
                try {
                    loadingIndicator.classList.remove('hidden');
                    const response = await retryFetch(CSV_URL); 
                    const csvText = await response.text();
                    
                    allCardData = csvToObjectArray(csvText);
                    
                    groupedCardData = groupCards(allCardData);
                    
                    fetchSuccess = groupedCardData.length > 0;

                } catch (error) {
                    console.error(error);
                    statusIndicator.innerHTML = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏"; 
                    itemsCountLabel.textContent = "–û—à–∏–±–∫–∞";
                }
            }
            
            if (!fetchSuccess) {
                allCardData = sampleData;
                groupedCardData = groupCards(allCardData);
                
                statusIndicator.innerHTML = `<p class='text-center font-semibold p-4 rounded-xl bg-gray-200/50 border border-gray-300/50 metal-effect mt-8'>
                                                 ‚úÖ –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                                               </p>`;
            }

            if (groupedCardData.length > 0) {
                loadingIndicator.classList.add('hidden');
                if (!statusIndicator.innerHTML.includes("–¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ")) statusIndicator.innerHTML = ''; 
                
                populateCategoryFilter(allCardData);
                renderGrid(groupedCardData);
                
                searchBar.addEventListener('input', filterDrinks);
                categoryFilter.addEventListener('change', filterDrinks); 

            } else {
                statusIndicator.innerHTML = "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö";
                itemsCountLabel.textContent = "–ù–∞–π–¥–µ–Ω–æ: 0";
            }
            loadingIndicator.classList.add('hidden');
        }
        
        async function retryFetch(url, retries = 3, delay = 1000) {
            if (url.includes("!!! –í–°–¢–ê–í–¨–¢–ï –°–Æ–î–ê")) throw new Error("URL –Ω–µ –∑–∞–º–µ–Ω–µ–Ω");
            const finalUrl = url + (url.includes('?') ? '&' : '?') + 't=' + new Date().getTime();
            for (let i = 0; i < retries; i++) {
                try {
                    const res = await fetch(finalUrl);
                    if (!res.ok) throw new Error(res.status);
                    return res;
                } catch (e) {
                    if (i === retries - 1) throw e;
                    await new Promise(r => setTimeout(r, delay * (2 ** i)));
                }
            }
        }

        window.onload = loadData;

    </script>
</body>
</html>
